# Java 同步工具类

# 信号量 Semaphore
1. **基本概念**： Semaphore中管理着一组许可，许可的初始数量可以通过构造函数指定，执行操作前时首先需要获得（acquire）许可（如果还有剩余），并在使用后释放（release）许可，如果没有许可，那么acquire将阻塞知道许可
2. **实现类**：Semaphore
3. **应用场景示例**
    * 实现资源池
4. [示例代码](SemaphoreTest.java)：有界集合BoundedHashSet

# 闭锁 Latch
1. **基本概念**：相当于一扇门，闭锁到达结束状态前，门一直关着，所有线程都不能通过。当到达结束状态时，门打开并允许所有线程通过。并且保持结束状态不再改变
2. **实现类**： CountDownLatch
3. **应用场景示例**：
    * 确保某个计算在其需要的所有资源都被初始化后才继续执行
    * 确保某个服务在其依赖的所有其他服务都启动后才启动
    * 等待直到某个操作的所有参与者都就绪再继续执行
4. [示例代码](LatchTest.java)：控制所有子线程同时开始执行，统计所有线程执行时间（从开始到最后一个执行完）

# 栅栏 Barrier
1. **基本概念**
    * 类似于闭锁， 能阻塞一组线程直到某个事件发生
    * 与闭锁的区别在于，所有线程必须同时到达栅栏位置，才能继续执行。
    * 闭锁用于等待时间，而栅栏用于等待其他线程，例如：几个家庭决定在某个地方结合：“所有人下午6点在麦当劳碰头，到了以后要等其它人，都到齐后再讨论下一步要做的事”
2. **实现类**
    * CyclicBarrier
        - 将一个问题拆解为一系列相对独立的子问题
        - 当线程到达栅栏位置时，调用await方法，这个方法将阻塞知道所有线程都到达栅栏位置
        - 所有线程都到达栅栏位置后，栅栏打开，所有线程都被释放，栅栏被重置以便下次使用
        - 如果对await调用超时，或者await阻塞被中断，那么栅栏被打破，所有阻塞await的调用线程都会终止并抛出BrokenBarrierException
        - CyclicBarrier可以将一个Runnable传给构造函数，如果成功通过栅栏，传入的Runnable将被执行（最后一个到达的线程）
        - [示例代码](BarrierTest.java)
    * Exchanger
        - 双方（Two-Party）栅栏，双方在栅栏位置上交换数据。即两个线程之间在栅栏处进行数据交换
        - 比如一个线程向写缓冲区写数据，一个从读缓冲区读数据，当读缓冲区为空，写缓冲区为满时交换两个缓冲区
        - [示例代码](ExchangerTest.java)


# FutureTask + callable 编程之美总结


## Reference：
1. 《Java并发编程实践》


